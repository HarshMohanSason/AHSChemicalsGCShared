package orders

import (
	"context"
	"encoding/base64"
	"fmt"
	"log"

	"cloud.google.com/go/firestore"
	firebase_shared "github.com/HarshMohanSason/AHSChemicalsGCShared/shared/firebase"
)

// CreateOrderInFirestore creates a new order in firestore. The automatic id generated by firestore is set as the ID of the order object
func CreateOrderInFirestore(order *Order, ctx context.Context) error {
	log.Printf("Creating an order in firestore for the user: %s", order.Uid)

	formattedOrderForFirestore := FormatOrderForFirestore(order)
	docRef, _, err := firebase_shared.FirestoreClient.Collection("orders").Add(ctx, formattedOrderForFirestore)
	order.ID = docRef.ID // Assign the generated ID to the order object

	if err != nil {
		return err
	}
	return nil
}

// Uploads an order related file to storage (Invoice, Shipping Manifest, etc.)
func UploadOrderRelatedFileToStorage(orderID string, base64Str string, fileName string, ctx context.Context) error {
	log.Printf("Uploading an order related file to storage")

	bucket, err := firebase_shared.StorageClient.Bucket(firebase_shared.StorageBucket)
	if err != nil {
		return err
	}
	object := bucket.Object(fmt.Sprintf("orders/%s/%s", orderID, fileName))
	decodedBytes, err := base64.StdEncoding.DecodeString(base64Str)
	if err != nil {
		return fmt.Errorf("failed to decode base64: %v", err)
	}

	writer := object.NewWriter(ctx)
	writer.ContentType = "application/pdf"

	if _, err := writer.Write(decodedBytes); err != nil {
		return fmt.Errorf("failed to write to object: %v", err)
	}

	if err := writer.Close(); err != nil {
		return fmt.Errorf("failed to close writer: %v", err)
	}

	return nil
}

// Not passing the order object here. Only the ID and the details object is passed which only contains the required fields to be updated along with their values
func UpdateOrderInFirestore(orderID string, details any, ctx context.Context) error {
	log.Printf("Updating an order in firestore for the admin")

	_, err := firebase_shared.FirestoreClient.Collection("orders").Doc(orderID).Set(ctx, details, firestore.MergeAll)

	if err != nil {
		return err
	}
	return nil
}

func FetchCustomerFromOrder(customerID string, ctx context.Context) (map[string]any, error) {
	log.Printf("Fetching the customer:%s from order for processing order pricing", customerID)

	docSnapshot, err := firebase_shared.FirestoreClient.Collection("customers").Doc(customerID).Get(ctx)
	if err != nil {
		return nil, err
	}
	return docSnapshot.Data(), nil
}

func FetchCustomerPriceForEachProductID(productIDs map[string]float64, customerId string, context context.Context) error {
	log.Printf("Fetching customer price for each product id: %v", customerId)

	docsSnapshots, err := firebase_shared.FirestoreClient.Collection("product_prices").Where("customer_id", "==", customerId).Documents(context).GetAll()
	if err != nil {
		return err
	}

	for _, docSnapshot := range docsSnapshots {
		docData := docSnapshot.Data()

		product_id, ok := docData["product_id"].(string)
		if !ok {
			return fmt.Errorf("Invalid or missing 'product_id' for customer %s", customerId)
		}

		if _, exists := productIDs[product_id]; exists {
			switch v := docData["price"].(type) {
			case float64:
				productIDs[product_id] = v
			case int64:
				productIDs[product_id] = float64(v)
			default:
				productIDs[product_id] = 0.0 // 0.0 is the default
			}
		}
	}
	return nil
}

func FetchOrderFromFirestore(orderID string, ctx context.Context) (*Order, error) {

	log.Printf("Fetching an order from firestore")

	docSnapshot, err := firebase_shared.FirestoreClient.Collection("orders").Doc(orderID).Get(ctx)
	if err != nil {
		return nil, err
	}
	if !docSnapshot.Exists() {
		return nil, fmt.Errorf("order with ID %s not found", orderID)
	}

	var order Order
	if err := docSnapshot.DataTo(&order); err != nil {
		return nil, err
	}
	return &order, nil
}